# Arbitrage Program - Демонстрационная версия

## Обзор

Эта программа представляет собой **обрезанную демонстрационную версию** полноценной Rust программы для арбитража на блокчейне Solana. Программа написана полностью с нуля и демонстрирует арбитраж между пулами **Pumpswap** и **Raydium AMM**.

## Поддерживаемые DEX

### В демонстрационной версии:
- **Pumpswap**
- **Raydium AMM**

### В полной версии дополнительно поддерживаются:
- **Raydium CLMM**
- **Raydium CPMM**
- **Meteora DLMM**
- **Meteora DAMM V2**

## Алгоритм арбитража

### Универсальный алгоритм оптимизации

Основной алгоритм находится в `programs/arbitrage_program/src/arbitrage_engine/arb_algorithms/universal.rs`.

**Принцип работы:**
1. **Анализ цен** - вычисляется разница цен между двумя пулами
2. **Бинарный поиск** - используется модифицированный бинарный поиск для нахождения оптимальной суммы
3. **Итеративная оптимизация** - алгоритм итеративно уменьшает шаг поиска до достижения оптимума
4. **Проверка прибыльности** - на каждой итерации рассчитывается потенциальная прибыль

Это базовый алгоритм. В полной версии реализованы еще 2 более сложных алгоритма, специально оптимизированных для минимизации потребления Compute Units (CU). Например специальный для DLMM, так как там необходима итерация по бинам.

## Оптимизация десериализации

### Частичная десериализация аккаунтов

Программа использует кастомную десериализацию для экономии CU:

```rust
// Пример из Pumpswap
let (base_mint_pubkey, quote_mint_pubkey) = PfAmmPool::deserialize_mints(&pool_bytes)?;
let fee_config = FeeConfig::deserialize_data(&fee_config_bytes)?;
```

**Преимущества подхода:**
- **Экономия CU** - десериализуются только необходимые поля
- **Снижение потребления памяти** - избегаем загрузки избыточных данных

В полной версии для **Meteora DLMM** используется `bytemark` подход:
- `bin_array` структуры слишком большие для полной десериализации (10000+ bytes/account)

### Использование AccountInfo

Программа использует `AccountInfo` вместо Anchor аккаунтов для устранения лишних проверок и дополнительной экономии CU.

## Swap методы

### Точные расчеты без погрешностей

Каждый DEX имеет собственную реализацию swap методов:

```rust
impl BasePool for PumpswapPool {
    fn swap(&self, amount_in: u64, min_amount_out: u64, source_to_intermediate: bool) -> Result<()> {
        // CPI вызов к оригинальному DEX
        // Расчет amount_out 1:1 как в оригинале
    }
}
```

**Ключевые особенности:**
- **CPI вызовы** к оригинальным программам DEX
- **Идентичные расчеты** - математика полностью соответствует оригинальным DEX
- **Нулевые погрешности** - результаты совпадают с прямыми вызовами DEX
- **Унифицированный интерфейс** через трейт `BasePool`

## Context аккаунты для верификации

### Система двойной проверки прибыльности

Программа реализует дополнительный уровень безопасности через context аккаунты:

**Процесс верификации:**
1. **Инициализация контекста** - создается `ArbitrageContext` аккаунт перед выполнением арбитража
2. **Сохранение начального состояния** - записываются балансы SOL и токенов пользователя
3. **Выполнение арбитража** - основная логика арбитража между пулами
4. **Верификация результата** - проверяется, что итоговые балансы больше начальных

```rust
// Инициализация контекста
arb_ctx.start_sol = user.lamports();
arb_ctx.start_src = get_ata_balance(user_source_token_account)?;

// Верификация после арбитража
let start_total = arb_ctx.start_sol + arb_ctx.start_src;
let curr_total = curr_sol + curr_src;
require!(curr_total >= start_total, ErrorCode::ArbitrageVerificationFailed);
```

Это обеспечивает дополнительную гарантию прибыльности операции на уровне программы.

## Архитектура

```
programs/arbitrage_program/src/
├── arbitrage_engine/          # Ядро арбитражного движка
│   ├── arb_algorithms/        # Алгоритмы оптимизации
│   └── base/                  # Базовые трейты и структуры
├── dex/                       # Интеграции с DEX
│   ├── pumpswap/             # Pumpswap интеграция
│   └── raydium_amm/          # Raydium AMM интеграция
├── instructions/              # Anchor инструкции
├── commons/                   # Общие утилиты
│   └── arbitrage_context/    # Система верификации контекста
└── state/                     # Состояние программы
```

## Демонстрационная транзакция

Пример реальной транзакции арбитража из полной версии программы:

**[wz1aRw63hbkr8cssAaDvYdvBsPM7Cru1hL9jZBVWvZUjjWaKhh8Cid4Dz2a6tf6PyTtx23P5jkBozPMUdbRq3Jf](https://solscan.io/tx/wz1aRw63hbkr8cssAaDvYdvBsPM7Cru1hL9jZBVWvZUjjWaKhh8Cid4Dz2a6tf6PyTtx23P5jkBozPMUdbRq3Jf)**

**Структура транзакции:**
1. **Flashloan** - берется займ 100 WSOL (~$22,720) на Kamino
2. **Инициализация PDA** - создается контекст аккаунт для верификации
3. **Арбитраж** - выполняется арбитраж между Meteora DLMM и Pumpswap:
   - Swap 20.51 WSOL → 1,516,206 dollo на Meteora DLMM
   - Swap 1,516,206 dollo → 21.61 WSOL на Pumpswap
4. **Верификация и возврат** - проверяется прибыльность и возвращается flashloan

**Технические особенности:**
- Транзакция подписана через **advanceNonce** для предотвращения повторного выполнения
- Возможность отправки с нескольких локаций одновременно
- Прошла через обычное SWQOS RPC (обычно используются tip для forwarders типа 0slot, nextblock, bloxroute)
- **Прибыль**: ~1.1 WSOL (~$250) с оборота $22,720

Данная демонстрационная версия показывает основные принципы и сложности реализации эффективного арбитража на Solana. Полная версия содержит значительно больше протоколов, алгоритмов оптимизации и продвинутых техник управления ресурсами.
